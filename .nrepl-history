(require '[clojure.spec :as s])
(s/valid? (s/cat bool? string?) [true "a"])
(s/valid? (s/cat :b bool? :a string?) [true "a"])
(s/valid? (s/cat :b boolean? :a string?) [true "a"])
(s/valid? (s/cat :b boolean? :a string?) [true "a" "s"])
(s/valid? (s/cat :b (s/* boolean?) :a string?) [true "a"])
(s/valid? (s/cat :b (s/* boolean?) :a string?) [[true false] "a"])
(s/valid? (s/* boolean?) [true false])
(s/valid? (s/* boolean?) [true false 2])
(s/valid? (s/* boolean?) true)
exit
(require '[clojure.spec :as s])
(defn a [n] (take n (constant "a")))
(constant "a")
(constantly "a")
(take 5 (constantly "a"))
(take (constantly "a") 5)
(repeat "a")
(defn a [n] (take n (repeat "a")))
(a 10)
(defn isa [s] (= s "a"))
(defn isa? [s] (= s "a"))
(defn a? [s] (= s "a"))
(repeat [(s/? a?)])
(take 10 (repeat [(s/? a?) a?]))
(take 2 (repeat [(s/? a?) a?]))
(flatten (take 2 (repeat [(s/? a?) a?])))
(apply s/cat (flatten (take 2 (repeat [(s/? a?) a?]))))
(macroexpand '(s/cat :str string?))
(defmacro apply-macro [macro args]
   `(apply (functionize ~macro) ~args))
(apply-macro s/cat (flatten (take 2 (repeat [(s/? a?) a?]))))
(defmacro functionize [macro]
  `(fn [& args#] (eval (cons '~macro args#))))
(apply-macro s/cat (flatten (take 2 (repeat [(s/? a?) a?]))))
(apply-macro s/cat (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(defn aspec [n] (apply-macro s/cat (flatten (take n (repeat [:a? (s/? a?) :a a?])))))
(aspec 10)
(s/valid? (aspec 10) (a 10))
(a 10)
(doc s/valid?)
(s/valid? (aspec 10) (a 10))
(aspec 10)
(s/valid? string? (a 10))
(s/valid? (s/? a?) (a 10))
(s/valid? (s/cat (s/? a?)) (a 10))
(s/valid? (s/cat :a (s/? a?)) (a 10))
(apply-macro s/cat (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(flatten (take 2 (repeat [:a? (s/? a?) :a a?])))
(apply-macro s/cat (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(a? 2)
(a? "a")
(apply-macro s/cat (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(s/valid? (aspec 10) (a 10))
(s/conform (aspec 10) (a 10))
(eval "(+ 1 2)")
(eval '(+ 1 2))
(flatten (take 2 (repeat [:a? (s/? a?) :a a?])))
(into '(s/cat)) (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(into '(s/cat) (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(vec (flatten (take 2 (repeat [:a? (s/? a?) :a a?])))))
(vec (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))
(into ['s/cat] (vec (flatten (take 2 (repeat [:a? (s/? a?) :a a?])))))
(seq (into ['s/cat] (vec (flatten (take 2 (repeat [:a? (s/? a?) :a a?]))))))
(eval (seq (into ['s/cat] (vec (flatten (take 2 (repeat [:a? (s/? a?) :a a?])))))))
(defn aspec [n] (eval (seq (into ['s/cat] (vec (flatten (take 2 (repeat [:a? (s/? a?) :a a?])))))))
)
(defn aspec [n] (eval (seq (into ['s/cat] (vec (flatten (take n (repeat [:a? (s/? a?) :a a?]))))))))
(aspec 10)
(s/valid? (aspec 10) (a 10))
(s/valid? (aspec 10) 1)
(a 10)
(s/valid? (s/cat :str? string?) 1)
(s/valid? (s/cat :str? string?) (a 10))
(a 10)
(string? "a")
(s/valid?  (s/* string?) (a 10))
(s/valid?  (s/* (s/? a?)) (a 10))
(s/valid?  (s/+ (s/? a?)) (a 10))
(s/valid?  (s/+ a?) (a 10))
(s/valid?  (s/+ (s/cat :a (s/? a?) :b a?)) (a 10))
(s/valid?  (s/+ (s/cat :a (s/? a?) :b a?)) (a 99))
(s/valid?  (s/+ (s/cat :a (s/? a?) :b a?)) (a 20))
(s/valid?  (s/+ (s/cat :a (s/? a?) :b a?)) (a 25))
(s/valid?  (s/+ (s/cat :a (s/? a?) :b a?)) (a 30))
(s/string)
(s/or (s/and string? number?) nil?)
(s/or :s1 (s/and string? number?) :s2 nil?)
(doc s/and)
(s/or :s1 (s/and :a string? :b number?) :s2 nil?)
(s/valid? "33" (s/or :s1 (s/and :a string? :b number?) :s2 nil?))
(s/valid? (s/or :s1 (s/and :a string? :b number?) :s2 nil?) 33)
(doc s/or)
(def ss (s/or (s/and string? number?) nil?))
(def ss (s/or :a (s/and string? number?) :b nil?))
(ss "a")
(doc reify)
(require '[clojure.spec :as s])
(s/cat)
(s/* (s/or bool? number?))
(s/* "bool" (s/or "bool" bool? "num" number?))
(s/* (s/or "bool" bool? "num" number?))
(s/* (s/or :bool bool? :num number?))
(s/* (s/or :bool boolean? :num number?))
(s/or)
(s/and)
(s/cat)
(s/* bool?)
(s/* boolean?)
(s/* boolean? boolean?)
exit
(require '[clojure.spec :as s])
(s/cat :a boolean? :b number?)
(s/conform (s/cat :a boolean? :b number?) [true 3])
(s/conform (s/cat :a (s/cat :c number) :b number?) [true 3])
(s/conform (s/cat :a (s/cat :c number?) :b number?) [true 3])
(s/cat :c number?)
(s/conform (s/cat :a (s/cat :c number?) :b number?) [true 3])
(s/conform (s/cat :a (s/* number?) :b number?) [true 3])
(s/* number?)
(s/conform (s/cat :a (s/cat :c number?) :b number?) [true 3])
(s/cat :a (s/cat :c number?) :b number?)
(s/conform (s/cat :a (s/cat :c boolean?) :b number?) [true  3])
(s/conform (s/cat :a (s/cat :c boolean?) :b number?) [[true]  3])
(s/conform (s/cat :a (s/cat :c boolean?) :b number?) [true  3])
(s/conform (s/cat :a (s/coll-of :c boolean?) :b number?) [true  3])
(s/conform (s/cat :a (s/collof :c boolean?) :b number?) [true  3])
(s/conform (s/cat :a (s/coll-of :c boolean?) :b number?) [true  3])
(s/conform (s/cat :a (s/coll-of boolean?) :b number?) [true  3])
(s/conform (s/cat :a (s/coll-of boolean?) :b number?) [[true]  3])
exit
(require '[clojure.spec :as s])
(s/and)
 (s/* boolean?)
(s/conform (s/* boolean?) [true true false])
(s/conform (s/* boolean?) [true [true] true false])
(s/conform (s/* boolean?) [[true true false]])
(s/conform (s/cat (s/* boolean?)) [[true true false]])
(s/conform (s/* (s/* boolean?)) [[true true false]])
(s/conform (s/collOf boolean?) [[true true false]])
(s/conform (s/coll-of boolean?) [[true true false]])
(s/conform (s/cat (s/coll-of boolean?)) [[true true false]])
(s/conform (s/cat :bools (s/coll-of boolean?)) [[true true false]])
exit
(require '[clojure.spec :as s])
(s/conform (s/cat :bools (s/* boolean?)) [true true false])
(s/conform (s/cat :bools (s/* boolean?) (s/* boolean?)) [true true false])
(s/conform (s/cat :bools (s/* boolean?) :bools2 (s/* boolean?)) [true true false])
(s/conform (s/cat :bools (s/* boolean?) :bools2 (s/* number?)) [true true false])
(s/conform (s/cat :bools (s/* boolean?) :bools2 (s/* number?)) [true true false 3])
(s/conform (s/cat :bools (s/* boolean?) :bools2 (s/* number?)) [true true false 5])
(s/conform (s/* (s/cat :bool boolean? :num number?)) [true true false 5])
(s/conform (s/* (s/cat :bool boolean? :num number?)) [true 2])
(s/conform (s/* (s/cat :bool boolean? :num number?)) [true 2 false 3])
(s/conform (s/cat :a (s/cat :bool boolean? :num number?)) [true 2 false 3])
(s/conform (s/cat :a (s/cat :bool boolean? :num number?) :b boolean) [true 2 false 3])
(s/conform (s/cat :a (s/cat :bool boolean? :num number?) :b boolean) [true 2 false])
(s/conform (s/cat :a (s/cat :bool boolean? :num number?) :b boolean) [[true 2] false])
(s/conform (s/or :a (s/cat :bool boolean? :num number?) :b boolean) [[true 2]])
(s/conform (s/or :a (s/cat :bool boolean? :num number?) :b boolean?) [[true 2]])
(s/conform (s/or :a (s/cat :bool boolean? :num number?) :b boolean?) [[true 2] false])
(s/conform (s/or :a (s/cat :bool boolean? :num number?) :b boolean?) [true 2 false])
(s/conform (s/cat :a (s/cat :bool boolean? :num number?) :b boolean?) [true 2 false])
(s/conform (s/cat :a (s/cat :bool boolean? :num number?) :b boolean?) [[true 2] false])
exit
(require '[clojure.spec :as s])
(s/(s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])
(s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])
(s/conform (s/cat :i1 integer? :m (s/keys :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])
(s/explain (s/cat :i1 integer? :m (s/keys :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])
(s/def ::port number?)
(s/def ::host string?)
(s/def ::id keyword?)
(s/def ::server (s/keys* :req [::id ::host] :opt [::port]))
(s/conform ::server [::id :s1 ::host "example.com" ::port 5555])
(s/def ::server (s/keys :req [::id ::host] :opt [::port]))
(s/conform ::server [::id :s1 ::host "example.com" ::port 5555])
(s/def ::config (s/*
                  (s/cat :prop string?
                         :val  (s/alt :s string? :b boolean?))))
(s/conform ::config ["-server" "foo" "-verbose" true "-user" "joe"])
(s/def ::config (s/* (s/cat :prop string? :val  (s/alt :s string? :b boolean?))))
(s/def ::config (s/* (s/cat :prop string? :val  (s/or :s string? :b boolean?))))
(s/conform ::config ["-server" "foo" "-verbose" true "-user" "joe"])
(def peg? #{:y :g :r :c :w :b})
(s/def ::code (s/coll-of peg? :min-count 4 :max-count 6))
(s/fdef score
        :args (s/cat :secret ::code :guess ::code))
(s/exercise (:args (s/get-spec `score)))
exit
(require '[clojure.spec :as s])
(require '[clojure.spec.test :as stest])
(def peg? #{:y :g :r :c :w :b})
(s/def ::code (s/coll-of peg? :min-count 4 :max-count 6))
(s/fdef score
        :args (s/cat :secret ::code :guess ::code))
(s/exercise (:args (s/get-spec `score)))
(s/get-spec `score)
(defn peg? [x] (= x :w))
(s/exercise (:args (s/get-spec `score)))(s/def ::code (s/coll-of peg? :min-count 4 :max-count 6))
(s/fdef score
        :args (s/cat :secret ::code :guess ::code))
(s/exercise (:args (s/get-spec `score)))
(def peg? #{:y :g :r :c :w :b})
(s/def ::code (s/coll-of peg? :min-count 4 :max-count 6))
(s/fdef score
        :args (s/cat :secret ::code :guess ::code))
(s/fdef score
        :args (s/and (s/cat :secret ::code :guess ::code)
                     (fn [{:keys [secret guess]}]
                       (= (count secret) (count guess)))))
(s/exercise (:args (s/get-spec `score)))
(s/def ::exact-matches nat-int?)
(s/def ::loose-matches nat-int?)
(s/fdef score
        :args (s/and (s/cat :secret ::code :guess ::code)
                     (fn [{:keys [secret guess]}]
                       (= (count secret) (count guess))))
        :ret (s/keys :req [::exact-matches ::loose-matches]))
(s/exercise (:ret (s/get-spec `score)))
(s/fdef score
        :args (s/and (s/cat :secret ::code :guess ::code)
                     (fn [{:keys [secret guess]}]
                       (= (count secret) (count guess))))
        :ret (s/keys :req [::exact-matches ::loose-matches])
        :fn (fn [{{secret :secret} :args ret :ret}]
              (<= 0 (apply + (vals ret)) (count secret))))
(defn score [secret guess]
  {::exact-matches 0
   ::loose-matches 0})
(s/exercise-fn `score)
(stest/check `score)
(defn score [secret guess]
  {::exact-matches 4
   ::loose-matches 3})
(s/exercise-fn `score)
(defn score [secret guess]
  {::exact-matches (count (filter true? (map = secret guess)))
   ::loose-matches 0})
(s/exercise-fn `score)
(stest/check `score)
(defn exact-matches [secret guess]
  (count (filter true? (map = secret guess))))
(defn score [secret guess]
  {::exact-matches (exact-matches secret guess)
   ::loose-matches 0})
(s/def ::secret-and-guess (s/and (s/cat :secret ::code :guess ::code)
                          (fn [{:keys [secret guess]}]
                            (= (count secret) (count guess)))))
(s/fdef score
        :args ::secret-and-guess
        :ret (s/keys :req [::exact-matches ::loose-matches])
        :fn (fn [{{secret :secret} :args ret :ret}]
              (<= 0 (apply + (vals ret)) (count secret))))
exit
